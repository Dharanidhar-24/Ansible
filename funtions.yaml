- name: functions
  hosts: localhost
  connection: local
  become: yes
  vars:
    technologies: Devops, AWS, Linux, Ansible # It is string
    name: Dharanidhar
    gmail: Dhar@GMAIL.COM
    ipaddr: 192.168.0.1
    # Dictnoary/Maps
    tags:
      Application: Payment
      Environment: Dev
    # Lists
    listtags:
      - key: Dharanidhar
        value: Payment
      - key: Environment
        value: Dev
  tasks:
  - name: default variable
    ansible.builtin.debug:
      msg: "Hello, {{ name | default('Dharanidhar') }}" 
      # Here we didnot define any variable but we are calling it. if we assign any variable it will take it
      # Otherwise it will pick it from default function in this case we didn't assign variable it is taking from default.
 
 # Convert string to lists
  - name: convert string to lists
    ansible.builtin.debug:                           
      msg: "Technologies are {{ technologies | split(',') }}" 
      #"msg": "Technologies are Devops, AWS, Linux, Ansible" if we didn't use any functions/filters.
      #"msg": "Technologies are ['Devops', ' AWS', ' Linux', ' Ansible']" After applying split filter it became string to lists.

  # Convert Maps to lists
  - name: convert maps/Dictnoary to lists
    ansible.builtin.debug:
      msg: "Tags are: {{ tags | dict2items }}"
      #"msg": "Tags are: {'Application': 'Payment', 'Environment': 'Dev'}" ==> Before
      #"msg": "Tags are: [{'key': 'Application', 'value': 'Payment'}, {'key': 'Environment', 'value': 'Dev'}]" ==> After

  # Convert lists into Maps/Dictnoary
  - name: convert lists into Maps
    ansible.builtin.debug:
      msg: "Maps are {{ listtags | items2dict }}"
     #"msg": "Maps are [{'key': 'Dharanidhar', 'Value': 'Payment'}, {'key': 'Environment', 'Value': 'Dev'}]"   ==> Before
     #"msg": "Maps are {'Dharanidhar': 'Payment', 'Environment': 'Dev'}".  ==> After


# fruits:
#   - fruit: apple
#     color: red
#   - fruit: pear
#     color: yellow
#   - fruit: grapefruit
#     color: yellow
# In this example, you must pass the key_name and value_name arguments to configure the transformation. For example:

# {{ fruits | items2dict(key_name='fruit', value_name='color') }}
# If you do not pass these arguments, or do not pass the correct values for your list, you will see KeyError: key or KeyError: my_typo

  - name: read yaml and take it to variable
    ansible.builtin.set_fact:      # it is used to store data into variable dynamically
      student_yaml: "{{ lookup('file', 'student.yaml') | from_yaml }}" #lookup is used to read the file

  - name: convert yaml to json
    ansible.builtin.debug:
      msg: "To json {{ student_yaml | to_json }}"

  - name: save json to file
    ansible.builtin.copy:
      dest: ./student_data.json
      content: "{{ student_yaml | to_nice_json }}"
  
  - name: convert lower to uppercase
    ansible.builtin.debug:
      msg: "Name: {{ name | upper }}"
      #msg": "Name: DHARANIDHAR"

  - name: convert upper to lower
    ansible.builtin.debug:
      msg: "Gmail: {{ gmail | lower }}"
      #"msg": "Gmail: dhar@gmail.com"

  - name: Check ipaddr is valid or not
    ansible.builtin.debug:
      msg: "IPADDRESS: {{ ipaddr | ansible.utils.ipv4 }}"
      #"msg": "IPADDRESS: False" if we give wrong ip address
      #"msg": "IPADDRESS: 192.168.0.1"
      # here we need to install dependencies "netaddr"
      #check ansible version "ansible --version"
      # pip3.9 install netaddr (ansible is developed by python. Its dependencies can be download by pip and 3.9 is the version)
  
  - name: grep for root
  #ansible.builtin.command: cat /etc/passwd | grep root  ==> by using command we cannot execute complex commands
    ansible.builtin.shell: cat /etc/passwd | grep root
    register: command_output #Here register is the keyword it will store the the output in variable

# command -> a simple command no need of access to shell environment like variables, bash, piping, etc..
# shell Module -> can access variabless, pipes, redirections, shell environment, etc.

  - name: print the command_output
    ansible.builtin.debug:
      msg: "{{ command_output }}" #Here we are printing the variable

  - name: redirect the output
    ansible.builtin.command: ls -ltr > /tmp/output.txt
    register: output
    ignore_errors: true #it will ignore the errors

  - name: print redirect output
    ansible.builtin.debug:
      msg: "{{ output }}"


